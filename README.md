# vanilla-editor

> vanilla-editor는 오직 Vanilla JS만을 사용하여 노션의 사이드바와 에디터를 구현하는 프로젝트입니다.
> 

## 소개

- editor가 가질 수 있는 가장 기본적인 기능에 집중하여, 사용자는 오직 내용을 작성에만 집중할 수 있습니다.
- 작성과 동시에 실시간으로 저장됩니다. 더 이상 열심히 작성한 작업물들을 저장 버튼을 누르지 않아 날라갈 걱정은 접어두세요!

## 기술 스택

- vanilla JS
- TypeScript

## 특징

1. 콘텐츠 업데이트와 동시에 실시간으로 서버에 저장합니다.
2. 디바운스를 활용하여 서버와 통신하는 횟수를 줄입니다.
3. history, fetch api를 활용하여 SPA 형식으로 구성하였습니다.

### 구조적 특징

**클래스를 사용하여 컴포넌트를 구현하였습니다.**

모든 컴포넌트는 `Component` 부모 클래스로부터 상속받아 작성되었습니다. 모든 컴포넌트는 `Component`라는 동일한 특징을 갖기 때문입니다.

또한, `class` 문법을 사용하여 보다 체계적으로 컴포넌트를 작성하기 위해 노력했습니다.

**상위 컴포넌트에서 하위 컴포넌트로 데이터가 흐르도록 설계하였습니다.**

자식 컴포넌트가 부모 컴포넌트의 상태를 바꿀 수 없도록 하여, 특정 컴포넌트의 변경이 전체에 영향을 줄 수 없도록 하였습니다. 또한 쉬운 유지 보수 및 디버깅 효과를 기대할 수 있습니다.

**하위 컴포넌트로 단방향 데이터 흐름에 따른 prop-drilling 현상을 극복하기 위하여 observer pattern의 전역 상태 관리 모델을 도입하였습니다.**

**[ 도입 배경 ]**

기존에는 App.js에서 다른 컴포넌트에서 접근할 수 있는 데이터들을 모두 정의하고 관리하였습니다. 이에 따라 다음의 문제가 발생했습니다.

1. App의 역할이 너무 크다.
    1. App 컴포넌트가 routing 처리 및 상태관리 역할을 모두 수행한다.
2. Sidebar 데이터의 낙관적 업데이트를 위해 트리 자료구조 및 bfs 탐색법을 사용하였다.
    1. `DocumentTree` 데이터에 최종적으로 접근해야 하기 때문에, App.js와 관련 없는 메서드들이 App.js 내부에 존재해야 한다.
3. Sidebar 컴포넌트 외에도 Modal 컴포넌트와 Editor 컴포넌트에서 제목이 변경될 때마다 `DocumentTree` 상태를 변경하기한 콜백 함수를 정의해야 한다. 해당 부분도 모두 컴포넌트 내부에 존재하므로 가독성을 떨어뜨리는 원인이 된다.
4. 장기적으로 더 많은 하위 컴포넌트들이 생성될 때, 해당 데이터로 접근하기 위한 prop-drilling 현상에 대한 우려

따라서 해당 문제를 근본적으로 해결하기 위해 전역 상태 관리의 필요성을 느꼈고, 전역 상태의 변경이 발생할 때, 해당 상태에 접근하는 컴포넌트들을 실시간으로 업데이트 하기 위하여 Observer 패턴 형식의 스토어로 구현하였습니다.

**[ 도입 후 효과 ]**

1. App 컴포넌트의 역할 감소
    1. App.js의 역할은 initial load시 서버로부터 데이터를 불러오는 역할과, 라우팅 처리의 역할만 하게 되었습니다.
2. App.js 내부의 상태를 조작하는 콜백 함수들의 제거되었습니다.
    1. 300줄에 가까운 앱 컴포넌트를 100줄 초반으로 리팩터링하였고, 따라서 가독성이 향상되었습니다.
3. 더 이상 View가 업데이트 되었는지 걱정할 필요가 없습니다.
    1. 데이터가 업데이트 됨에 따라 업데이트해야 하는 컴포넌트들이 많아질수록 setState 내부에 새로운 컴포넌트들을 등록해야 하는데, 이 과정에서 실수가 일어날 가능성이 많았습니다. 그런데 전역 상태 관리에서는 `render()` 메서드를 `subscribde` 함수를 통해 구독만 시켜놓으면 되기 때문에 렌더링이 안 될지 걱정할 필요가 없습니다.

**[ 전역 상태 관리 도입을 통해 배운 것 ]**

- 클로저에 대해 조금 더 이해할 수 있게 되었습니다.
    - 기존에는 클로저를 단순히 이론적으로만 알고 있었습니다. *(함수가 선언되었을 때 주변 환경을 기억하기 때문에, 자신이 선언되었을 때의 환경 밖에서 호출하더라도 선언되었을 때 주변 환경의 변수 또는 함수에 접근할 수 있는 함수)*
    - `createStore` 메서드와 `observable` 메서드에 클로저 구조를 도입하면서, `initialState`를 보호할 수 있으며 데이터의 흐름을 강제할 수 있었습니다. 따라서 클로저의 특징인 캡슐화와 정보의 은닉에 대해 실질적으로 체감할 수 있었습니다.

**[ 해당 방법말고는 없었나? ]**

- 전역 상태 관리를 도입하지 않고 해결할 수 있는 방법
    - 해당 프로젝트를 진행할 당시에는 전역 상태 관리 도입이 최선의 방법이라고 생각했으나, 지금 이전의 코드를 다시 보니, 전역 상태 관리의 도입 없이 코드의 가독성을 개선할 수 있어 보입니다.
    - 기존 코드에서 DocumentTree util은 Tree 구조를 다루는데 필요한 함수들을 정의해 두었지만, 상태와 관련된 메서드들까지 완벽하게 App.js로부터 분리하지 못했습니다.
    - 그러나 도메인이 없는 Tree 클래스를 구성하여, 해당 함수는 보다 순수한 함수들로 구성될 수 있도록 하고, Tree 클래스로부터 상속받아 DocumentTree 클래스를 만들어, 해당 클래스 내에서 좀 더 도메인에 가깝도록 데이터를 조작할 수 있을 듯 합니다. (물론, 나중에 다시 돌아와서 보면, 해당 방식보다 더 좋은 방식으로 리팩토링을 시도할 수 있을것입니다.)
    - 코드
        
        ```tsx
        // Tree.ts
        class Tree {
          find() {}
        
          add() {}
        
          pop() {}
          // ...
        }
        
        // DocumentTree.ts
        class DocumentTree extends Tree {
          constructor(initialState: Document) {
            this.tree = initialState
          }
        
          addToTree(document: Document) {}
        
          popFromTree() {}
        
          get() {
            return this.tree
          }
        }
        
        // App.ts
        class App extends Component {
          // ...
          onAdd() {
            const treeController = new DocumentTree([...this.state.documentTree])
            treeController.addToTree(document)
            // ...
          }
        }
        ```
        
    - DocumentTree 데이터를 완벽히 DocuementTree class에서 조작할 수 있도록 하여, 콜백 함수 내부에서는 실제로 조작된 데이터를 상태에 반영하는 형식을 따르면 좀 더 단일 책임 원칙에 가까운 구조를 만들 수 있을 듯 합니다. 이런 구조를 도입하면, 상태에 따른 의존성이 낮아지기 때문에 전역 상태 관리 도입의 필요성을 느낀 몇 가지 이유들을 해소할 수 있을 것이라 생각합니다. (추후 해당 방식으로 리팩토링을 시도해 보겠습니다.)

## 추후 계획

- 책임이 명확하게 분리되지 않은 컴포넌트 및 유틸 함수에 대해 리팩토링 진행
- 새로운 빌드 환경 구성
    - webpack 번들러 도입, 수정 사항에 대해 실시간 감시 및 에러 추적
    - babel을 이용하여 구형 브라우저 환경 지원
    - editorconfig, eslint, prettier 패키지를 통해 체계적인 코드 품질 유지
    - github action을 도입하여 병합 전 eslint 에러 체크